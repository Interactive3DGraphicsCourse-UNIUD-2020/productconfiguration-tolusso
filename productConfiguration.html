<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Lightsaber</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background-color: #f0f0f0;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				color: #222;
				padding: 5px;
				font-family: Monospace;
				font-size: 13px;
				text-align: center;
			}

			a {
				color: #000;
				text-decoration: none;
			}

			a:hover {
				color: #0080ff;
			}
		</style>
	</head>
	<body>
		<script src="libs/three.js"></script>
		<script src="libs/stats.min.js"></script>
		<script src="libs/OrbitControls.js"></script>
		<script src='libs/dat.gui.min.js'></script>
		<script src='libs/GLTFLoader.js'></script>
		<script src='libs/BufferGeometryUtils.js'></script>

		<!-- shaders -->

		<script type="text/x-glsl" id="vertexM">
		precision highp float;
		precision highp int;
		attribute vec4 tangent;
		varying vec3 vNormal;
		varying vec3 vTangent;
		varying vec3 vBitangent;
		varying vec3 vPosition;
		varying vec2 vUv;

		void main() {
			vec4 vPos = modelViewMatrix * vec4( position, 1.0 );
			vPosition = vPos.xyz;
			vNormal = normalize(normalMatrix * normal);
			vec3 objectTangent = vec3( tangent.xyz );
			vec3 transformedTangent = normalMatrix * objectTangent;
			vTangent = normalize( transformedTangent );
			vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
			vUv = uv;
			gl_Position = projectionMatrix * vPos;
		}
		</script>

		<script type="text/x-glsl" id="fragmentM">
			precision highp float;
			precision highp int;
			varying vec3 vNormal;
			varying vec3 vTangent;
			varying vec3 vBitangent;
			varying vec3 vPosition;
			varying vec2 vUv;
			uniform vec3 pointLightPosition;
			uniform vec3 lightColor;
            uniform sampler2D specularMap;
			uniform sampler2D diffuseMap;
            uniform sampler2D roughnessMap;
            uniform sampler2D AO;
			uniform sampler2D normalMap;
			uniform samplerCube envMap;

			const float PI = 3.14159;
            #define saturate(a) clamp( a, 0.0, 1.0 )
            vec3 cdiff;
			vec3 cspec;
			float roughness;

			vec3 FSchlick(float lDoth) {
				return (cspec + (vec3(1.0)-cspec)*pow(1.0 - lDoth,5.0));
			}

			float DGGX(float nDoth, float alpha) {
				float alpha2 = alpha*alpha;
				float d = nDoth*nDoth*(alpha2-1.0)+1.0;
				return (  alpha2 / (PI*d*d));
			}

			float G1(float dotProduct, float k) {
				return (dotProduct / (dotProduct*(1.0-k) + k) );
			}

			float GSmith(float nDotv, float nDotl) {
					float k = roughness*roughness;
					return G1(nDotl,k)*G1(nDotv,k);
			}

			float pow2( const in float x ) { return x*x; }

			float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {
		 		float maxMIPLevelScalar = float( maxMIPLevel );
		 		float desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );
		 		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );
		 	}

			float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
		  		return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
		  	}

			vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
				return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
			}

			vec3 BRDF_Specular_GGX_Environment( vec3 normal, vec3 viewDir, const in vec3 cspec, const in float roughness ) {

				float dotNV = saturate( dot( normal, viewDir ) );
				const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
				const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
				vec4 r = roughness * c0 + c1;
				float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
				vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;
				return cspec * AB.x + AB.y;

			}

			void main() {
				roughness = pow( texture2D( roughnessMap, vUv).rgb, vec3(2.2)).r;
				vec3 normal = normalize( vNormal );
				vec3 tangent = normalize( vTangent );
				vec3 bitangent = normalize( vBitangent );
				mat3 vTBN = mat3( tangent, bitangent, normal );
				vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
				mapN.xy = vec2(1) * mapN.xy;
				vec3 n = normalize( vTBN * mapN );
				vec3 v = normalize( -vPosition);
				vec3 vReflect = reflect(vPosition,n);
                vec3 r = inverseTransformDirection( vReflect, viewMatrix );
                cspec = texture2D( specularMap, vUv ).rgb;
                cspec = pow( cspec, vec3(2.2));
                cdiff = texture2D( diffuseMap,vUv ).rgb;
				cdiff = pow( cdiff, vec3(2.2));
				cspec = cspec * cdiff; //la texture del manico è una metalmap non una specular

				float blinnShininessExponent = GGXRoughnessToBlinnExponent(roughness);
				float specularMIPLevel = getSpecularMIPLevel(blinnShininessExponent, 8 );

	 			vec3 envLight = textureCubeLodEXT( envMap, vec3(-r.x, r.yz), specularMIPLevel ).rgb;
	 			// texture in sRGB, linearize
				envLight = pow( envLight, vec3(2.2));
				vec3 outRadiance = envLight*BRDF_Specular_GGX_Environment(n, v, cspec, roughness)+(cdiff*texture2D( AO, vUv ).xyz).xyz * 0.2;
				
				//BRDF per point light usando come luce quella emessa dalla lama
				if(lightColor != vec3(0)){
					vec4 lPosition = viewMatrix * vec4( pointLightPosition, 1.0 );
					float distance = sqrt((vPosition.x - lPosition.x) * (vPosition.x - lPosition.x) +
									(vPosition.y - lPosition.y) * (vPosition.y - lPosition.y) +
									(vPosition.z - lPosition.z) * (vPosition.z - lPosition.z));
					float att = clamp(1.0 - distance/0.35, 0.0, 1.0); //0.35 è il raggio, molto piccolo perchè la luce non arrivi al resto del modello
					att *= att; // la luce adrà ad attenuarsi
					vec3 l = normalize(lPosition.xyz - vPosition.xyz);
					vec3 h = normalize( v + l);
					float nDotl = max(dot( n, l ),0.000001);
					float lDoth = max(dot( l, h ),0.000001);
					float nDoth = max(dot( n, h ),0.000001);
					float vDoth = max(dot( v, h ),0.000001);
					float nDotv = max(dot( n, v ),0.000001);
					vec3 fresnel = FSchlick(lDoth);
					vec3 BRDF = (vec3(1.0)-fresnel)*cdiff/PI + fresnel*GSmith(nDotv,nDotl)*DGGX(nDoth,roughness*roughness)/
						(4.0*nDotl*nDotv);
					outRadiance = outRadiance + PI * lightColor * 100.0 * att * nDotl * BRDF; // 100 serve per aumentare l'intensità
				}
				// gamma encode the final value
				gl_FragColor = vec4(pow( outRadiance * 0.5, vec3(1.0/2.2)), 1.0);
				//gl_FragColor = vec4(r,1.0);
			}
		</script>

		<script type="text/x-glsl" id="vertexL">
			attribute vec4 tangent;
			varying vec3 vNormal;
			varying vec3 vPosition;
			varying vec3 wPosition;
			varying vec3 vTangent;
			varying vec3 vBitangent;
	
			void main() {
				vec4 vPos = modelViewMatrix * vec4( position, 1.0 );
				vPosition = vPos.xyz;
				wPosition = (modelMatrix * vec4( position, 1.0 )).xyz;
				vNormal = normalize(normalMatrix * normal);
				vec3 objectTangent = vec3( tangent.xyz );
				vec3 transformedTangent = normalMatrix * objectTangent;
				vTangent = normalize( transformedTangent );
				vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
				gl_Position = projectionMatrix * vPos;
			}
			</script>
	
			<script type="text/x-glsl" id="fragmentL">
				varying vec3 vNormal;
				varying vec3 vTangent;
				varying vec3 vBitangent;
				varying vec3 vPosition;
				varying vec3 wPosition;
				uniform vec3 cspec;
				uniform samplerCube envMap;
                uniform float material;
                uniform vec3 lightColor;
				const float PI = 3.14159;
	
				vec3 FSchlick(float lDoth, vec3 cspec) {
					return (cspec + (vec3(1.0)-cspec)*pow(1.0 - lDoth,5.0));
				}
	
				vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
					return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
				}
				void main() {
					vec3 normal = normalize( vNormal );
					vec3 tangent = normalize( vTangent );
					vec3 bitangent = normalize( vBitangent );
					mat3 vTBN = mat3( tangent, bitangent, normal );
					vec3 n = normalize( vTBN * normal );
					vec3 v = normalize( -vPosition);
					vec3 worldN = inverseTransformDirection( n, viewMatrix );
                    vec3 worldV = cameraPosition - wPosition ;
                    float nDotv = max(dot( n, v ),0.000001);
					vec3 fresnel = FSchlick(nDotv, cspec);
					vec3 outRadiance;
					
                    if(material == 1.0){ //acqua
						vec3 refractV = refract(-worldV,worldN,0.750);
						vec3 reflectV = reflect(-worldV,worldN);
						vec3 refractEnvLight = textureCube( envMap, vec3(-refractV.x, refractV.yz)).rgb;
						vec3 reflectEnvLight = textureCube( envMap, vec3(-reflectV.x, reflectV.yz)).rgb;
						refractEnvLight = pow( refractEnvLight, vec3(2.2));
						reflectEnvLight = pow( reflectEnvLight, vec3(2.2));
						vec3 fresnelRefract = FSchlick(nDotv, (vec3(1) - cspec));
                        outRadiance = refractEnvLight*fresnelRefract + fresnel*reflectEnvLight;
                    }
                    if(material == 2.0){ //ferro
						vec3 r = reflect(-worldV,worldN);
						vec3 envLight = textureCube( envMap, vec3(-r.x, r.yz)).rgb;
						envLight = pow( envLight, vec3(2.2));
                        outRadiance = fresnel*envLight;
                    }
                    if(material == 3.0){ //luce
                        outRadiance = vec3(max(nDotv * 1.0,lightColor.r),max(nDotv * 1.0,lightColor.g),max(nDotv * 1.0,lightColor.b)) ;
                    }
                    gl_FragColor = vec4(pow( outRadiance, vec3(1.0/2.2)), 0.0);
                    
				}
			</script>
		<!-- three.js code -->

		<script>

			var renderer = new THREE.WebGLRenderer( { antialias: true } );
			var camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 1, 1000 );
			var controls = new THREE.OrbitControls( camera, renderer.domElement );
			var scene = new THREE.Scene();

			var loader = new THREE.CubeTextureLoader();
				loader.setPath( 'textures/Space/' );

				var textureCube = loader.load( [
					'posx.png', 'negx.png',
					'posy.png', 'negy.png',
					'posz.png', 'negz.png'
				] );

			scene.background = textureCube;

			textureCube.minFilter = THREE.LinearMipMapLinearFilter;


			var normalMap = loadTexture( "textures/lightsaber/normal.png" );
			var diffuseMap = loadTexture( "textures/lightsaber/albedo.jpg" );
			var specularMap = loadTexture( "textures/lightsaber/metallic.jpg" );
			var roughnessMap = loadTexture( "textures/lightsaber/roughness.jpg" );
			var AO = loadTexture( "textures/lightsaber/AO.jpg" );

			var lamaParameters = {
				unsheathe: false,
				material: "Light",
                lightColor: 0xff0000,
			}

			var mUniforms = {
                		specularMap: { type: "t", value: specularMap},
						diffuseMap:	{ type: "t", value: diffuseMap},
						roughnessMap:	{ type: "t", value: roughnessMap},
                        AO:	{ type: "t", value: AO},
				        normalMap:	{ type: "t", value: normalMap},
						envMap:	{ type: "t", value: textureCube},
						lightColor: { type: "v3", value: lamaParameters.lightColor },
						pointLightPosition:	{ type: "v3", value: new THREE.Vector3(0,0,0) },
					};

			vsm = document.getElementById("vertexM").textContent;
			fsm = document.getElementById("fragmentM").textContent;

			materialExtensions = {
				shaderTextureLOD: true
			};

			var mMaterial = new THREE.ShaderMaterial({ uniforms: mUniforms, vertexShader: vsm, fragmentShader: fsm,
			 extensions: materialExtensions });

			var loader = new THREE.GLTFLoader();
			loader.useIndices = true;
				loader.load( "models/lightsaber/Lightsaber.glb", function ( model ) {
					console.log(model);
					geometry = model.scene.children[ 0 ].children[0].geometry;
					//geometry = obj.children[0].geometry;
					geometry.center();
					mesh = new THREE.Mesh( geometry, mMaterial );
					mesh.position.set(0,-1.4,0);
					mesh.scale.multiplyScalar( 0.01 );
					mesh.rotation.z = 270 * Math.PI/180;
					mesh.rotation.y = 180 * Math.PI/180;
					THREE.BufferGeometryUtils.computeTangents(geometry);
					scene.add( mesh );
				} );

			

			var lUniforms = {
				cspec:	{ type: "v3", value: new THREE.Vector3(0.562,0.565,0.578) },
				envMap:	{ type: "t", value: textureCube},
				material: { type: "f", value: lamaParameters.material },
                lightColor: { type: "v3", value: lamaParameters.lightColor }
			};

			vsl = document.getElementById("vertexL").textContent;
			fsl = document.getElementById("fragmentL").textContent;

			var lMaterial = new THREE.ShaderMaterial({ uniforms: lUniforms, vertexShader: vsl, fragmentShader: fsl });

			function loadBlade() { 
				var loader = new THREE.GLTFLoader();
				loader.useIndices = true;
				loader.load( "models/lightsaber/lama.glb", function ( model ) {
					geometry = model.scene.children[ 0 ].geometry;
					geometry.center();
					mesh = new THREE.Mesh( geometry, lMaterial );
					mesh.scale.set(0.1,0.1,0.1);
					mesh.position.set(0,1.3,0.02);
					THREE.BufferGeometryUtils.computeTangents(geometry);
					mesh.name = "lama";
					scene.add( mesh );
				} );
			}
			

			function removeEntity(object) {
				var selectedObject = scene.getObjectByName(object.name);
				scene.remove( selectedObject );
			}

			function loadTexture(file) {
					var texture = new THREE.TextureLoader().load( file , function ( texture ) {

						texture.minFilter = THREE.LinearMipMapLinearFilter;
						texture.anisotropy = renderer.getMaxAnisotropy();
						texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
    			  texture.offset.set( 0, 0 );
						texture.needsUpdate = true;
						render();
					} )
					return texture;
			}

			var gui;
			var stats = new Stats();
			

			function init() {

				renderer.setClearColor( 0xf0f0f0 );

				camera.position.set( 0, 0, 10 );
				scene.add( camera );

				document.body.appendChild( renderer.domElement );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );

				controls.minDistance = 1;
				controls.maxDistance = 100;
				controls.enablePan = false;
				controls.update();

				window.addEventListener( 'resize', onResize, false );

			    stats.domElement.style.position = 'absolute';
			    stats.domElement.style.top = '0px';
			    document.body.appendChild( stats.domElement );

				mMaterial.needsUpdate = true;
				lMaterial.needsUpdate = true;



			}

			function onResize() {

				renderer.setSize( window.innerWidth, window.innerHeight );
				camera.aspect = ( window.innerWidth / window.innerHeight );
				camera.updateProjectionMatrix();

			}

			function update() {
				requestAnimationFrame( update );
				stats.update();
				render();
			}

			function render() {
				updateUniforms();
				renderer.render( scene, camera );

			}

			function clearGui() {

				if ( gui ) gui.destroy();
				gui = new dat.GUI();
				gui.open();

			}

			function buildGui() {

				clearGui();
				gui.add(lamaParameters,'unsheathe').onChange( function (value) {
					if(!value){
						removeEntity(mesh);
					}else{
						loadBlade();
					}
				});
				lamaMaterial = gui.addFolder('Blade Material');
				lamaMaterial.add(lamaParameters,'material',[ "Water", "Light", "Iron" ]);
                lightColor = lamaMaterial.addColor(lamaParameters,'lightColor');
			}

			function updateUniforms() {
				if(lamaParameters.material == "Water"){
					lUniforms.material.value = 1.0;
					lUniforms.cspec.value = new THREE.Vector3(0.04,0.04,0.04);
					lightColor.domElement.hidden = true;
				}
				if(lamaParameters.material == "Iron"){
					lUniforms.material.value = 2.0;
					lUniforms.cspec.value = new THREE.Vector3(0.562,0.565,0.578);
					lightColor.domElement.hidden = true;
				}
				if(lamaParameters.material == "Light"){
					lUniforms.material.value = 3.0;
					mUniforms.lightColor.value = new THREE.Color(lamaParameters.lightColor);
					lUniforms.lightColor.value = new THREE.Color(lamaParameters.lightColor);
					lightColor.domElement.hidden = false;
				}
				if(!lamaParameters.unsheathe || lamaParameters.material!="Light"){
					mUniforms.lightColor.value = new THREE.Color(0x000000);
					lightColor.domElement.hidden = true;
				}
			}

			init();
			buildGui();
			update();
			render();

		</script>
	</body>
</html>
